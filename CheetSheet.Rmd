Cheetsheet für R

PS05 REGEX
```{r}
#. steht für jedes mögliche Zeichen
#* steht für 0 oder mehr Vorkommen
#+ steht für 1 oder mehr Vorkommen
#? steht für 0 oder 1 Vorkommen
#[] Menge wird gesucht aber nur eine Position
#[^] Alles außer Menge wird gesucht aber nur eine Position
#{} Anzahl der Vorkommen
#() Gruppierung und Gruppen bilden für referenzierung
# \b Wortgrenze

grep("^[A-Z]", input, value = TRUE) #Alle Wörter die mit einem Großbuchstaben beginnen  Value True gibt Match zurück ansonsten Position
grepl("^[A-Z]", input, value = TRUE) #gibt einen Logical Vector zurück

sub("[^a-zA-Z]", "", input) #Ersetzt alle Zeichen bis auf Buchstaben durch nichts (nur bei erstem Treffer)
gsub("[^a-zA-Z]", "", input) #Alle Zeichen bis auf Buchstaben ersetzen 

regexpr() #gibt die Position des ersten Matches zurück als Liste
gregexpr() #gibt die Position aller Matches zurück als Liste

regexec() #gibt die Position des ersten Matches zurück und die einzelnen Gruppen in Spalten 
gregexec() #gibt die Position aller Matches zurück und die einzelnen Gruppen in Spalten

#matches ausgeben
matches <- gregexpr("(?<!^)(?<!\\.\\s)([A-Z])\\w+", text, perl = TRUE) #RegEx kann natürlich angepasst werden
found <- regmatches(text, matches)
```


PS07 Randomness and Reproducibility
```{r}
sample(values, replace = TRUE)#replace müsste zurücklegen sein
```

PS08/PS09 Data Tables
```{r}
datatable[i,j]
#i wird benutz wie in dplyr filter also z.b col1 < 5 oder ähnliches und bekomme die Zeilen worauf das zutrifft
# man kann expressions reinschreiben !!! z.b auch sample um zufällige zeilen zu ziehen

#j
#mit , with = FALSE macht die J Spalte so wie bei einem DF
#alles außer liste erzeugt vector 
#listen erzeigen neuen data table unabhängig von der länge des alten DT
#:= ist wie der Zuweisungspfeil in dplyr vergleichbar mit mutate


#entfernen einer Spalte
b[, "id" := NULL]

#NAs in 0 umwandeln
result[is.na(count), count := 0]

#namen und reihenfolge ändern
setnames(result, c("online", "onsite"), c("count.online", "count.onsite"))
setcolorder(result, c("item", "count.onsite", "count.online"))

#Operation bei einem Right Merge anwenden (prices right merge sales mit "item", wendet die Operation in der Mitte an)
prices[sales, ifelse(channel == "online", price.online, price.onsite), on = "item"]

#rolling joins brauch ich auch

#CJ = Crossjoin es noch einen keyby parameter aber da muss ich nochmal syntax anschauen 

setnafill #sau hilfreich

#setekeyv

```

PS10 OOP
```{r}

```


Vectoren / Funktionen 
```{r}
#Am besten immer versuchen mit [] zu filtern oder replacen 


#Funktionen
which() # rückgabewert ist ein Vector #hat ein Argument: arr.ind welches pos von mehrdiminsionalen Objekten zurückgibt

which.max()
which.min()

all() # alle Werte sind TRUE
any() # mindestens ein Wert ist TRUE
ifelse() #ifelse Rückgabewert hat gleich lönge wie eingabe schlecht zum löschen

paste(, collapse = "") #Setzt Variablen und String ect zusammen (collapse ist ein seperator)
rev() #dreht strings um 
strsplit(cleanInput, "") #splittet strings
```

Matrizen
```{r}

mat[bedingung,, drop = FALSE] #keine compression auf kleinen Dimension
```

Data Table 
```{r}
#Zeilen Counten
data[ , count := .N, by = ]

#Spalte löschen 
data[ , count := NULL]
data[ , .("alle anderen Spalten")]

#Merges 
#b lookup in a
a[b, on = c(...), nochmatch = NA] #nomatch bestimmt wie gefillt wird 

#Anti Merge 
a[!b, on = c(...)]
```

Applys
```{r}
vapply() #eifnaches apply für listen Rückgabewert muss definiert werden 

lapply() #einfaches apply das eine  Liste zurückgibt 

apply() #geeignet für matrizen und mehrdimensionale Sachen: 1 Zeilen 2 Spalten

replicate(n, func()) #führt eine Funktion mehrmals aus (optional gibt ein simplify argument)
```

Benchmarking
```{r}
#1. immer versuchen alles zu vectorisen 
#2. nested loops abschaffen 
```


Algos
```{r}

```

